---Question 1-------------------------------------------------------------------------
include irvine32.inc

.data
array SDWORD 30,-40,20,65,80,45
msgJ BYTE "Enter j: ", 0
msgK BYTE "Enter k: ", 0
msgSum BYTE "Sum of Array in Range: ", 0

.code
main PROC
	push offset array
	push lengthof array

	mov edx, offset msgJ
	call writestring
	call readint
	push eax
	
	mov edx, offset msgK
	call writestring
	call readint
	push eax

	call SumAll
	mov edx, offset msgSum
	call writestring
	call writeint
exit
main ENDP

;---------------------------------------------------------
SumAll PROC USES EBX ECX
;
; Calculates and returns the sum of all array elements falling within the range j and k
; Receives: ESI Offset to Doubleword Array, Size of Array, j, k (Passed through Stack)
; Returns: EAX = sum
; Requires: nothing
;---------------------------------------------------------
push ebp
mov ebp, esp
	mov esi, [ebp+28]
	mov ecx, [ebp+24]
	mov ebx, 0

	L1:
		mov eax, [esi]

		cmp eax, [ebp+20]
		jl skip

		cmp eax, [ebp+16]
		jg skip

		add ebx, eax

		skip:
			add esi, 4
		loop L1

		mov eax, ebx
mov esp, ebp
pop ebp
ret 16
SumAll ENDP

END main
---Question 1-------------------------------------------------------------------------


---Question 2-------------------------------------------------------------------------
include irvine32.inc

.data
array DWORD 60,4,17,45,7

.code
main PROC
	mov ecx, lengthof array
	mov esi, offset array

	outer:
		mov eax, [esi]
		push ecx
		push esi
		mov edi, esi
		inner:
			cmp [esi], eax
			jge skip

			mov edi, esi
			mov eax, [esi]

			skip:
			add esi, type array
			loop inner
		pop esi
		pop ecx

		call SWAP

		add esi, type array
		loop outer

	mov ecx, lengthof array
	mov esi, 0
	display:
		mov eax, array[esi*type array]
		call writeint
		inc esi
		loop display

exit
main ENDP

;---------------------------------------------------------
SWAP PROC USES EAX EBX
;
; Swaps two elements using their reference
; Receives: ESI and EDI
; Returns: nothing
; Requires: nothing
;---------------------------------------------------------
enter 0,0
	mov eax, [esi]
	mov ebx, [edi]

	mov [esi], ebx
	mov [edi], eax
leave
ret
SWAP ENDP

END main
---Question 2-------------------------------------------------------------------------


---Question 3-------------------------------------------------------------------------
include irvine32.inc

.data
array BYTE 10 DUP(?)
msg BYTE "Sorted Array Using BUBBLE: ", 0
msgInput BYTE "Enter Number: ", 0

.code
main PROC
	mov ecx, lengthof array
	mov esi, offset array
	mov edx, offset msgInput
	input:
		call writestring
		call readint
		mov [esi], al
		inc esi
		loop input

	mov ebx, lengthof array
	mov esi, offset array

	call BUBBLE

	mov esi, 0
	mov ecx, ebx

	mov edx, offset msg
	call writestring

	mov eax, 0
	mov ecx, lengthof array
	display:
		movzx eax, array[esi*type array]
		call writeint
		inc esi
		loop display

exit
main ENDP

;---------------------------------------------------------
BUBBLE PROC USES ECX
;
; Sorts an Array Using Bubble Sort
; Receives: Offset of Array in ESI, Length of Array in EBX
; Returns: nothing
; Requires: nothing
;---------------------------------------------------------
enter 0,0
	push ebx
	push esi

	mov edi, esi

	mov ecx, ebx
	outer:
		push esi
		push ecx
	
		mov esi, edi

		inner:
			mov al, [esi]
			mov bl, [esi+1]

			cmp bl, al
			jge skip

			mov [esi+1], al
			mov [esi], bl

			skip:
			inc esi
			loop inner

		pop ecx
		pop esi
		inc esi
		loop outer

	here:
	pop esi
	pop ebx
leave
ret
BUBBLE ENDP

END main
---Question 3-------------------------------------------------------------------------


---Question 4-------------------------------------------------------------------------
include irvine32.inc

.data

.code
main PROC
	mov ecx, 5
	call FACTORIAL
	call writeint

	call crlf

	mov ecx, 9
	call FACTORIAL
	call writeint
exit
main ENDP

;---------------------------------------------------------
FACTORIAL PROC
;
; Returns the Factorial of a Number
; Receives: Number N in ECX
; Returns: Factorial in EAX
; Requires: nothing
;---------------------------------------------------------
	mov eax, 1
	L1:
		mul cx
		loop L1
	ret
FACTORIAL ENDP

END main
---Question 4-------------------------------------------------------------------------


---Question 5-------------------------------------------------------------------------
include irvine32.inc

.data
prompt BYTE "TYPE A CHARACTER: ", 0
outp BYTE "THE ASCII CODE OF A IN BINARY IS ", 0
num BYTE "THE NUMBER OF 1 BITS IS ", 0
buffer BYTE 9 DUP(?)


.code
main PROC
	call BINTOASCII
exit
main ENDP

;---------------------------------------------------------
BINTOASCII PROC USES EAX EBX ECX EDX
;
; Displays the ASCII Code and Number of 1 Bits after Reading a Character
; Receives: nothing
; Returns: nothing
; Requires: nothing
;---------------------------------------------------------
	mov edx, offset prompt
	call writestring
	call readchar
	call writechar
	
	mov ecx, 8
	mov ebx, 0
	mov esi, offset buffer

	L1:
		shl al, 1
		mov BYTE PTR[esi], '0'
		jnc carry
		inc ebx
		mov BYTE PTR[esi], '1'

		carry:

		inc esi
		loop L1
		mov BYTE PTR[esi], 0

		call crlf
		mov edx, offset outp
		call writestring
		mov edx, offset buffer
		call writestring
		call crlf
		mov edx, offset num
		call writestring
		mov eax, ebx
		call writedec

	ret
BINTOASCII ENDP

END main
---Question 5-------------------------------------------------------------------------


---Question 6-------------------------------------------------------------------------
include irvine32.inc

CountMatches PROTO, off1: PTR SDWORD, off2: PTR SDWORD, len: DWORD

.data
array1 SDWORD 10,11,12,13,15
array2 SDWORD 11,12,12,13,14

array3 SDWORD 1,2,3,4,5,11
array4 SDWORD 6,7,8,9,10,11


.code
main PROC
	INVOKE CountMatches, ADDR array1, ADDR array2, lengthof array1
	call writeint
	call crlf
	INVOKE CountMatches, ADDR array3, ADDR array4, lengthof array3
	call writeint
	call crlf
exit
main ENDP

;---------------------------------------------------------
CountMatches PROC USES ECX EBX ESI EDI EDX, off1: PTR SDWORD, off2: PTR SDWORD, len: DWORD
;
; Counts number of same elements in Array
; Receives: Offset to two Arrays and Length of Array on the Stack
; Returns: Count of matching elements in EAX
; Requires: nothing
;---------------------------------------------------------
	mov esi, off1
	mov edi, off2
	mov ecx, len
	mov eax, 0

	L1:
		mov edx, [esi]
		mov ebx, [edi]
		cmp ebx, edx
		jne skip
		inc eax
		skip:
		add esi, 4
		add edi, 4
	loop L1

	ret
CountMatches ENDP

END main
---Question 6-------------------------------------------------------------------------


---Question 7-------------------------------------------------------------------------
include irvine32.inc

Extended_Sub PROTO, off1: PTR QWORD, off2: PTR QWORD, off3: PTR QWORD, len: DWORD

.data
num1 QWORD 0234567810111214h
num2 QWORD 0147892478912798h
ans QWORD 0


.code
main PROC
	INVOKE Extended_Sub, ADDR num1, ADDR num2, ADDR ans, (sizeof num1/type DWORD)
exit
main ENDP

;---------------------------------------------------------
Extended_Sub PROC, off1: PTR QWORD, off2: PTR QWORD, off3: PTR QWORD, len: DWORD
;
; Subtracts two Binary Integers of Arbitrary Size
; Receives: Offset to three Numbers including two Operands and One to Store Result
; Returns: Result of Subtraction in ans variable
; Requires: nothing
;---------------------------------------------------------
	pushad
	clc
	mov esi, off1
	mov edi, off2
	mov ebx, off3
	mov ecx, len
	L1:
		mov eax, [esi]
		sbb eax, [edi]
		pushfd
		mov [ebx], eax
		add edi, 4
		add ebx, 4
		add esi, 4
		popfd
	loop L1

	sbb word ptr[ebx], 0
	popad

	mov esi, off3
	mov ecx, len
	L3:
		add esi, 4
		loop L3
	mov ecx, len

	L2:
		sub esi, type dword
		mov eax, [esi]
		call writehex
		loop L2
	ret
Extended_Sub ENDP

END main
---Question 7-------------------------------------------------------------------------


---Question 8-------------------------------------------------------------------------
include irvine32.inc

Extended_Add PROTO, off1: PTR QWORD, off2: PTR QWORD, off3: PTR QWORD, len: DWORD

.data
num1 QWORD 0234567810111214h
num2 QWORD 0147892478912798h
ans QWORD 0


.code
main PROC
	INVOKE Extended_Add, ADDR num1, ADDR num2, ADDR ans, (sizeof num1/type DWORD)
exit
main ENDP

;---------------------------------------------------------
Extended_Add PROC, off1: PTR QWORD, off2: PTR QWORD, off3: PTR QWORD, len: DWORD
;
; Subtracts two Binary Integers of Arbitrary Size
; Receives: Offset to three Numbers including two Operands and One to Store Result
; Returns: Result of Subtraction in ans variable
; Requires: nothing
;---------------------------------------------------------
	pushad
	clc
	mov esi, off1
	mov edi, off2
	mov ebx, off3
	mov ecx, len
	L1:
		mov eax, [esi]
		adc eax, [edi]
		pushfd
		mov [ebx], eax
		add edi, 4
		add ebx, 4
		add esi, 4
		popfd
	loop L1

	sbb word ptr[ebx], 0
	popad

	mov esi, off3
	mov ecx, len
	L3:
		add esi, 4
		loop L3
	mov ecx, len

	L2:
		sub esi, type dword
		mov eax, [esi]
		call writehex
		loop L2
	ret
Extended_Add ENDP

END main
---Question 8-------------------------------------------------------------------------


---Question 9-------------------------------------------------------------------------
include irvine32.inc
.stack 1000000000

.data


.code
main PROC
	mov eax, 5
	push eax
	mov eax, 20
	push eax
	call GCD
	call writeint

	call crlf

	mov eax, 24
	push eax
	mov eax, 18
	push eax
	call GCD
	call writeint

	call crlf

	mov eax, 432
	push eax
	mov eax, 226
	push eax
	call GCD
	call writeint
exit
main ENDP

;---------------------------------------------------------
GCD PROC
;
; Calculates GCD of two numbers
; Receives: Two Integers on the Stack
; Returns: Result of GCD Calculation in EAX
; Requires: nothing
;---------------------------------------------------------
	push ebp
	mov ebp, esp
	
	mov ebx, [ebp+8]
	mov ecx, [ebp+12]

	cmp ebx, 0
	jne con2
	mov eax, ecx
	mov ebp, esp
	pop ebp
	ret 8

	con2:
	cmp ecx, 0
	jne con5
	mov eax, ebx
	mov ebp, esp
	pop ebp
	ret 8

	con5:
	cmp ebx, ecx
	jne con3
	mov eax, ebx
	mov ebp, esp
	pop ebp
	ret 8
	
	con3:
	cmp ebx, ecx
	jle con4
	sub ebx, ecx
	push ebx
	push ecx
	call gcd
	pop ebp
	ret 8

	con4:
	sub ecx, ebx
	push ebx
	push ecx
	call gcd
	pop ebp
	ret 8

	mov ebp, esp
	pop ebp
	ret 8
GCD ENDP

END main
---Question 9-------------------------------------------------------------------------


---Question 10-------------------------------------------------------------------------
include irvine32.inc

CountNearMatches PROTO, off1: PTR SDWORD, off2: PTR SDWORD, len: DWORD, diff: DWORD

.data
array1 SDWORD 10,11,12,13,15
array2 SDWORD 11,12,12,13,14
diff1 DWORD 1

array3 SDWORD 1,2,3,4,71,11
array4 SDWORD 40,50,60,60,70,13
diff2 DWORD 2


.code
main PROC
	INVOKE CountNearMatches, ADDR array1, ADDR array2, lengthof array1, diff1
	call writeint
	call crlf
	INVOKE CountNearMatches, ADDR array3, ADDR array4, lengthof array3, diff2
	call writeint
	call crlf
exit
main ENDP

;---------------------------------------------------------
CountNearMatches PROC USES ECX EBX ESI EDI EDX, off1: PTR SDWORD, off2: PTR SDWORD, len: DWORD, diff: DWORD
;
; Counts number of near match elements in Array
; Receives: Offset to two Arrays and Length of Array and Allowed Difference on the Stack
; Returns: Count of near matching elements in EAX
; Requires: nothing
;---------------------------------------------------------
	mov esi, off1
	mov edi, off2
	mov ecx, len
	mov eax, 0

	L1:
		mov edx, [esi]
		mov ebx, [edi]

		push ecx

		cmp edx, ebx
		jl con
		mov ecx, edx
		sub ecx, ebx

		con:
		mov ecx, ebx
		sub ecx, edx

		cmp ecx, diff
		pop ecx
		jg skip
		inc eax
		skip:
		add esi, 4
		add edi, 4
	loop L1

	ret
CountNearMatches ENDP

END main
---Question 10-------------------------------------------------------------------------







---------------------------------------Substring Removal Code--------------------------
include irvine32.inc

.data
target BYTE "abcxxxxdefghijklmnop",0
start_add DWORD 7
num_chars DWORD 2

.code
main PROC
	mov edi, offset target
	push edi
	mov eax, start_add
	push eax
	mov eax, num_chars
	push eax
	call str_remove
	mov edx, offset target
	call writestring


exit
main ENDP

	str_remove proc
		push ebp
		mov ebp, esp
		cld

		mov edi, [ebp+16]
		add edi, [ebp+12]
		
		mov esi, edi
		add esi, [ebp+8]

		mov ecx, lengthof target
		sub ecx, [ebp+12]
		sub ecx, [ebp+8]

		rep movsb
		
		pop ebp
		ret
	str_remove endp

END main
----------------------------------------------------------------------------------------





-----------------------------------Frequency Counter-----------------------------------
include irvine32.inc

.data
target BYTE "a brown burnt bear on a brushed bridge", 0
source BYTE 26 DUP(?)

.code
main PROC
	mov esi, offset target
	mov ecx, lengthof target

	L1:
		mov eax, 0
		mov edi, offset source
		mov al, [esi]
		cmp al, 'z'
		jg jump
		cmp al, 'a'
		jl jump

		sub al, 97
		add edi, eax
		mov bl, [edi]
		inc bl
		mov [edi], bl
		
		jump:
		inc esi
	loop L1

	mov ecx, lengthof source
	mov esi, offset source


	mov ebx, 97
	L2:
		mov al, [esi]
		cmp eax, 0
		je skip
		
		mov al, bl
		call writechar
		mov al, ' '
		call writechar


		mov eax, 0
		mov al, [esi]
		call writedec
		call crlf

		skip:
		inc ebx
		inc esi
	loop L2

exit
main ENDP


END main
-----------------------------------------------------------------------------------


------------------------------Word Reversal in String------------------------------
include irvine32.inc

.data
array BYTE "fast nuces building is best", 0
target BYTE 50 DUP (?)
register DWORD ?

.code
main PROC
	mov esi, offset array 
	mov edi, offset target
	
	mov ebx, 0

	add esi, lengthof array
	dec esi
	dec esi

	mov ecx, lengthof array

	L1:
		mov eax, 0
		mov al, [esi]
		cmp al, 0
		je skip
		cmp al, 20h
		jne skip

		mov register, ecx
		mov ecx, ebx
		inner:
			pop edx
			mov [edi], dl
			inc edi
			loop inner
		mov ebx, 0
		mov ecx, register

		mov byte ptr[edi], ' '
		inc edi
		jmp inout

		skip:
		push eax
		inc ebx
		inout:
		dec esi
		loop L1

	mov ecx, ebx
	L2:
		pop edx
		cmp dl, 0
		je outloop
		mov [edi], dl
		inc edi
		outloop:
		loop L2

	mov edx, offset target
	call writestring
exit
main ENDP


END main
--------------------------------------------------------------------------------------




--------------------------------------Concatenation of String-------------------------
include irvine32.inc

.data
string1 BYTE "hello world",0
string2 BYTE "nice man",0
target BYTE 50 DUP(?)

.code
main PROC
	mov esi, offset string1
	mov ecx, lengthof string1 - 1

	mov edi, offset target
	L1:
		mov al, [esi]
		mov [edi], al
		inc esi
		inc edi
		loop l1

	mov esi, offset string2
	mov ecx, lengthof string2
	L2:
		mov al, [esi]
		mov [edi], al
		inc esi
		inc edi
		loop L2
	

	mov edx, offset target
	call writestring
exit
main ENDP


END main
----------------------------------------------------------------------------------------


---------------------------------------Inline Assembly--------------------------------
#include<iostream>
using namespace std;

void ThreeProd(int, int, int);
int main()
{	
	int n[3];
	for (int x = 0; x < 3; x++) {
		cout << "Enter Number " << x + 1 << ": ";
		cin >> n[x];
	}
	ThreeProd(n[0], n[1], n[2]);
}
void ThreeProd(int n1, int n2, int n3) {
	int ans;
	_asm
	{
		mov eax, n1
		mov ebx, n2
		mov ecx, n3
		mul ebx
		mul ecx
		mov ans, eax
	}
	cout << "Multiplication of the 3 Numbers is: " << ans << endl;
}

#include<iostream>
using namespace std;

void GCD(int, int);
int main()
{	
	int n1;
	int n2;
	cout << "Enter number 1: ";
	cin >> n1;
	cout << "Enter Number 2: ";
	cin >> n2;
	GCD(n1, n2);
}
void GCD(int n1, int n2) {
	int t;
	int ans;
	_asm
	{	
	L1:
		mov eax, 0
		mov ebx, 0
		mov edx, 0
		mov eax, n1
		mov t, eax
		mov eax, n2
		mov n1, eax
		mov eax, t
		mov ebx, n2
		cmp ebx, 0
		je skip
		div ebx
		skip:
		mov n2, edx
		mov eax, n2
		cmp eax, 0
		je outx
		jmp L1
		outx:
		mov eax, n1
		mov ans, eax
	}
	cout << ans;
}

--------------------------------------------------------------------------------------



----------------------------------Loading An Array------------------------------------
include irvine32.inc

.data
array DWORD 1,2,3,4,5,6,7,8,9,10

.code
main PROC
	push offset array
	push lengthof array
	call multiply
exit
main ENDP

Multiply PROC
enter 0,0
	mov esi, [ebp+12]
	mov edi, esi
	mov ecx, lengthof array

	L1:
	lodsd
	mov ebx, 3
	mul ebx
	stosd
	loop L1

	mov esi, offset array
	mov ecx, lengthof array
	mov ebx, type array
	call dumpmem
leave
ret 8
Multiply ENDP


END main
--------------------------------------------------------------------------------------



--------------------------------------------------------------------------------------
; Creating a File (CreateFile.asm)
INCLUDE Irvine32.inc
BUFFER_SIZE = 501
.data
buffer BYTE BUFFER_SIZE DUP(?)
filename BYTE "output.txt",0
fileHandle HANDLE ?
stringLength DWORD ?
bytesWritten DWORD ?
str2 BYTE "Bytes written to file [output.txt]:",0
str3 BYTE "Enter up to 500 characters and press"
BYTE "[Enter]: ",0dh,0ah,0
.code
main PROC
; Create a new text file.
mov edx,OFFSET filename
call CreateOutputFile
mov fileHandle,eax
; Ask the user to input a string.
mov edx,OFFSET str3 ; "Enter upto ...."
call WriteString
mov ecx,BUFFER_SIZE ; Input a string
mov edx,OFFSET buffer
call ReadString
mov stringLength,eax ; counts chars entered
; Write the buffer to the output file.
mov eax,fileHandle
mov edx,OFFSET buffer
mov ecx,stringLength
call WriteToFile
mov bytesWritten,eax ; save return value
call CloseFile
; Display the return value.
mov edx,OFFSET str2 ; "Bytes written"
call WriteString
mov eax,bytesWritten
call WriteDec
call Crlf
exit
main ENDP
END main
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
; Reading a File (ReadFile.asm)
; Opens, reads, and displays a text file using
; procedures from Irvine32.lib.
INCLUDE Irvine32.inc
INCLUDE macros.inc
BUFFER_SIZE = 5000
.data
buffer BYTE BUFFER_SIZE DUP(?)
filename BYTE 80 DUP(0)
fileHandle HANDLE ?
.code
main PROC
; Let user input a filename.
mWrite "Enter an input filename: "
mov edx,OFFSET filename
mov ecx,SIZEOF filename
call ReadString
; Open the file for input.
mov edx,OFFSET filename
call OpenInputFile
mov fileHandle,eax
; Read the file into a buffer.
mov edx,OFFSET buffer
mov ecx,BUFFER_SIZE
call ReadFromFile
mov buffer[eax],0 ; insert null terminator
mWrite "File size: "
call WriteDec ; display file size
call Crlf
; Display the buffer.
mWrite <"Buffer:",0dh,0ah,0dh,0ah>
mov edx,OFFSET buffer ; display the buffer
call WriteString
call Crlf
mov eax,fileHandle
call CloseFile
exit
main ENDP
END main
----------------------------------------------------------------------
-------------------------------------------------------------------------------